
class Me
  def initialize u
    @user = U.new(u)
    @brain = Cerebrum.new
    @mood = Sentimental.new
    @mood.load_defaults
    @mood.threshold = 0.1
  end
  def mood
    @mood
  end
  def feel f
    @mood.sentiment f
    @mood.score f
  end
  
  def brain
    @brain
  end
  def learn loc
    da = {}
    @user.badges.members(with_scores: true).to_h.each_pair do |b, s|
      da[b] = (s / 1000000).to_f
    end
    dat = { input: da, output: { "#{loc}" => 1 }}
    @brain.train([dat])
  end
  def predict
    u = @user.badges.members(with_scores: true).to_h
    @brain.run(u)
  end
end

def learn d, u, l
  da = {}
  U.new(u).badges.members(with_scores: true).to_h.each_pair do |b, s|
    da[b] = (s / 1000000).to_f
  end
  dat = { input: da, output: { "#{l}" => 1 }}
  { me: ME[d][u].learn(l), we: WE[d].train([dat]) }
end

def predict d, u
  uu = U.new(u).badges.members(with_scores: true).to_h
  { me: ME[d][u].predict, we: WE[d].run(uu) }
end





def phone_tree phone, h={}
  if h.keys.length > 0
    TREE[phone] = JSON.generate(h)
  end
end


module Cypher
  def self.encrypt key, data
    return Cryptology.encrypt(data: data, key: key, cipher: 'CHACHA20-POLY1305')['data']
  end
  def self.decrypt key, data
    if Cryptology.decryptable?(data: data, key: key, cipher: 'CHACHA20-POLY1305')
      plain = Cryptology.decrypt(data: data, key: key, cipher: 'CHACHA20-POLY1305')
    else
      plain = false
    end
    return plain
  end
end

def user u
  U.new(u)
end

class Blockchain
  attr_accessor :chain, :current_transactions
  def initialize pfx
    @action = Redis::SortedSet.new('ACTION:' + pfx)
    @finger = Redis::SortedSet.new('FINGER:' + pfx)
    @chain = Redis::List.new('CHAIN:' + pfx, marshal: true)
    @a = Redis::HashKey.new('A:' + pfx)
    @l = Redis::HashKey.new('L:' + pfx)
    @current_transactions = []
    new_block(1, 100)
  end
  
  # Creates a new Block and adds it to the chain
  def new_block(proof, previous_hash = nil)
    block = {
      index: @chain.length + 1,
      epoch: Time.now.utc.to_f,
      transactions:  @current_transactions,
      cost:          @current_transactions.length - 1,
      proof:         proof,
      previous_hash: previous_hash || Blockchain.hash(@chain.last)
    }
    @current_transactions = []; @chain << block; block
  end
  
  def block_cost
    @current_transactions.length + 1
  end
  
  # Adds a new transaction to the list of transactions
  def new_transaction(sender, recipient, amount, fing, act)
    Redis.new.publish('Blockchain.new_transaction', "#{sender} #{recipient} #{amount} #{fing} #{act}")
    @action.incr("#{recipient}:#{act}")
    @finger.incr("#{recipient}##{fing.join(':')}")
    user(sender).coins.decrement(amount)
    user(recipient).coins.increment(amount)
    h = {
      epoch: Time.now.utc.to_f,
      sender: sender,
      recipient: recipient,
      amount: amount,
      fingerprint: fing,
      act: act
    }
    @current_transactions << h
    last_block[:index] + 1
    return h
  end
  
  def acts
    @action.members(with_scores: true).to_h
  end
  def fingers
    @finger.members(with_scores: true).to_h
  end
  
  def proof_of_work(last_proof); proof = 0; while !valid_proof?(last_proof, proof); proof += 1; end; proof; end
  def last_block; @chain.values.last; end
  def hash(block); Digest::MD5.hexdigest(block.sort.to_h.to_json.encode); end
  def uuid; SecureRandom.uuid.gsub("-", ""); end
  
  def [] a
    if !@l.has_key? a
      u = uuid
      @a[u] = a
      @l[a] = u
    end
    return @l[a]
  end
  
  private
  
  # Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes?
  def valid_proof?(last_proof, proof)
    Digest::MD5.hexdigest("#{last_proof}#{proof}".encode)[0..3] == "0000"
  end
end

BLOCKCHAIN = Blockchain.new('/')

class Broker
  
  def initialize h={}
    @h = h
    @c = PahoMqtt::Client.new
    @blocks = {}
    @c.on_message { |message|
      if @blocks.has_key? message.topic
        @blocks[message.topic].call(message.topic, JSON.parse(message.payload || "{}"))
      end
    }
    @c.connect(h[:host] || 'localhost', h[:port] || 1883)
  end
  def bridge l, &b
    @blocks[l] = b
    sub(topic: l)
  end
  def sub h={}
    @c.subscribe([h[:topic] || '#', h[:qos] || 2])
  end
  def pub h={}
    @c.publish(h[:topic], h[:payload], h[:retain] || false, h[:qos] || 1)
  end
  def client
    @c
  end
end


def code w, j={}
  CODE[w] = JSON.generate(j)
end

def timer h={}
  t = 0
  t += (h[:years].to_i * (365 * (24 * (60 * 60))))
  t += (h[:months].to_i * (30 * (24 * (60 * 60))))
  t += (h[:weeks].to_i * (7 * (24 * (60 * 60))))
  t += (h[:days].to_i * (24 * (60 * 60)))
  t += (h[:hours].to_i * (60 * 60))
  t += (h[:minutes].to_i * 60)
  t += h[:seconds].to_i
  return t
end

def token t, h={}
  if h.has_key? :ttl
    Redis.new.setex(t, h[:ttl], true)
  end
  return Redis.new.get(t)
end

class Phone
  def twilio
    if OPTS[:sid] != ''
      Twilio::REST::Client.new(ENV['PHONE_SID'], ENV['PHONE_KEY'])
    end
  end
  def send_sms h={}
    to = []
    [ h[:to] ].flatten.uniq.each do |t|
      if /^\+1#.+$/.match(t)
        if @cloud.zones.members.include? t.gsub(/\+1/, '')
          @cloud.zone(t.gsub(/\+1/, '')).admins.members.each { |e| to << e }
        else
          to << ENV['ADMIN']
        end
      elsif /^#.+/.match(t)
        if @cloud.zones.members.include? t
          @cloud.zone(t).admins.members.each {|e| to << e }
        else
          to << ENV['ADMIN']
        end
      else
        to << t
      end
    end
    to.each do |t|
      Redis.new.publish "DEBUG.send_sms", "#{t} #{h}"
      if OPTS[:sid] != ""
        if h[:body] != ''
          if h[:image]
            twilio.messages.create(
              to: t,
              from: ENV['PHONE'],
              body: h[:body],
              media_url: [ h[:image] ]
            )
          else
            twilio.messages.create(
              to: t,
              from: ENV['PHONE'],
              body: h[:body]
            )
          end
        end
      end
    end
  end
end
def phone
  Phone.new
end

class Tracks
  include Redis::Objects
  set :adventures
  set :waypoints
  hash_key :players
  def initialize i
    @id = i
  end
  def id; @id; end
  # an adventure track  
  def [] t
    if "#{t}".length > 0
    self.adventures << t
    z = Zone.new(t)
    z.adventures << adventure(t)
    Adventure.new(adventure(t))
    end
  end
  # user at waypoint
  def visit u, p
    if "#{u}".length > 0 && "#{p}".length > 0
      self.players[u] = p
      uu = U.new(u)
      uu.visited << p
      uu.attr[:waypoint] = p
      uu.attr.incr(:xp)
    end
  end

  #                  U   "say this" -> new track
  # zone, waypoint, password, for
  def mark z, w, p, f, a
    Redis.new.publish "WAYPOINT.mark", "#{z} #{w} #{p} #{f}"
    if "#{z}".length > 0 && "#{w}".length > 0 && "#{p}".length > 0 && "#{f}".length > 0
    @a = Adventure.new(adventure(z))
    @z = Zone.new(z)
    @z.adventures << adventure(z)
    @z.waypoints << @a[w].id
    @u = U.new(w)
    @u.waypoints << @a[w].id
    @a.contributors << @u.id
    @a[w].passwords[p] = { for: f }
    @a[w].attr[:goto] = a
    end
  end
  
  # collect aset of waypoints as a zone.
  def track zone, *waypoints
    if "#{zone}".length > 0
    self.adventures << zone
    a = Adventure.new(adventure(zone))
    z = Zone.new(zone)
    z.adventures << adventure(zone)
    [waypoints].flatten.each_with_index {|e, i|
      # adventure[waypoint].adventures << adventure(zone)
      if "#{e}".length > 0
      a[e].adventures << adventure(zone)
      z.waypoints << a[e].id
      end
    }
    return a
    end
  end
  
  def adventure p
    "#{@id}:#{p}"
  end
end


##
# TRACKS[request.host]track zone, *user
#
# TRACKS[request.host][zone].contributors << @user.id
# TRACKS[request.host][zone][waypoint].passwords[password] = { to: @user.id, for: desc }
#
# TRACKS[request.host][zone].visit(@user.id, waypoint)
#
# TRACKS[request.host][zone][waypoint].stat.incr(zone)
# TRACKS[request.host][zone].stat.incr(waypoint)

TRACKS = Hash.new {|h,k| h[k] = Tracks.new(k) }

class Adventure
  include Redis::Objects
  set :waypoints
  hash_key :attr
  set :contributors
  sorted_set :stat
  hash_key :players
  def initialize i
    @id = i
  end
  def id
    @id
  end
  def [] p
    if "#{p}".length > 0
    self.waypoints << p
    Waypoint.new(p)
    end
  end
end

class Waypoint
  include Redis::Objects
  set :adventures
  hash_key :attr
  sorted_set :stat
  hash_key :passwords, marshal: true
  def initialize i
    @id = i
  end
  def id
    @id
  end
end


class Board
  include Redis::Objects
  value :is
  def initialize i
    @id = i
  end
  def id
    @id
  end
  def form
    
  end
  def html
    o = []
    if self.is.value != nil
    @u = U.new(self.is.value)
    o << %[<img src='#{@u.attr[:img]}'>]
    o << %[<p>#{@u.attr[:name] || 'vacant'}</p>]
    else
      o << %[<input type='text' name='board[#{self.id}]' placeholder='user'>]
    end
    return %[<fieldset><legend>#{self.id}</legend>#{o.join('')}</fieldset>]
  end
end

class Contest
  include Redis::Objects
  sorted_set :votes
  sorted_set :voters
  set :pool
  def initialize i
    @id = i
  end
  def id
    @id
  end
  def leader
    x = self.votes[-1]
    return { user: x, votes: self.votes[x] }
  end
end

class Comms
  def initialize user, host
    @user = U.new(user)
    @host = host
    if ENV['cluster'] == 'localhost' && /.onion/.match(host)
      @here = host
    else
      @here = ENV['CLUSTER']
    end
    if MUMBLE.has_key? @here
      @port = MUMBLE[@here]
    else
      @port = ENV['MUMBLE']
    end
  end

  def cluster
    return %[mumble://#{@user.attr[:name] || 'nomad'}@#{ENV['CLUSTER']}:#{@port}/?version=1.2]                                                                   end
  def onion
    return %[mumble://#{@user.attr[:name] || 'nomad'}@#{Redis.new.get('ONION')}:#{@port}/?version=1.2]                                                           end
  def host
    return %[mumble://#{@user.attr[:name] || 'nomad'}@#{@host}:#{@port}/?version=1.2]
  end
  def here
    return %[mumble://#{@user.attr[:name] || 'nomad'}@#{@here}:#{@port}/?version=1.2]
  end
end

class Vote
  include Redis::Objects
  sorted_set :votes
  set :voters
  set :pool
  def initialize i
    @id = i
  end
  def id
    @id
  end
  def leaderboard
    a = []
    self.votes.revrange(0, -1).each {|e| a << { e => self.votes[e] } }
    return a
  end
  def leader
    x = self.votes[-1]
    return { user: x, votes: self.votes[x] }
  end
end

def votes
  v = {}
  VOTES.members.each {|e| v[e] = Vote.new(e).leaderboard }
  return v
end


class Zone
  include Redis::Objects
  set :pool
  set :users
  hash_key :jobs
  hash_key :items
  hash_key :attr
  counter :coins
  set :waypoints
  set :adventures
  set :urls
  def initialize i
    @id = i
  end
  def id
    @id
  end
  def pay a, *u
    [u].flatten.each {|e| Bank.xfer to: e, from: @id, amt: a }
  end
  def rm!
    Bank.xfer from: @id, amt: self.coins.value
    Redis.new.keys.each { |e| if /#{@id}/.match(e); Redis.new.del(e); end }
  end
end

module Shares
  def self.shares k
    o, s, r = 0, 0, SHARES[k].to_i || 100
    Redis::SortedSet.new("shares:#{k}").members(with_scores: true).to_h.each_pair {|k,v| if v > 0; o += 1; end; s += v; r -= v; }
    return {owners: o, held: s, max: SHARES[k].to_i, remaining: r}
  end
  def self.cost k
    o, s = 0, 0
    Redis::SortedSet.new("shares:#{k}").members(with_scores: true).to_h.each_pair {|k,v| o += 1; s += v }
    return ((2 ** o) + (2 ** "#{s.to_i}".length)) 
  end
  def self.by(k)
    Redis::SortedSet.new("shares:#{k}")
  end
  def self.mint k, u, *n
    if n[0]
      nn = n[0].to_i
    else
      nn = 1
    end
    Redis::SortedSet.new("shares:#{k}").incr(u, nn)
  end
  def self.burn k, u, *n
    if n[0]
      nn = n[0].to_i
    else
      nn = 1
    end
    Redis::SortedSet.new("shares:#{k}").decr(u, nn)
  end
end

module Bank
  ##              ##
  #                #
  # banking system #
  #                #
  ##              ##
  #
  # balance: U.new(@id).coins.value
  # credit: Bank.wallet[@id]
  #
  # - [balance] is the active amount of credits in a user's account.
  #   credits can be used to pay for industry to industry services
  #   and other sponsored events.
  #
  # - [credit] is the amount of credit purchased or earned and inactivated by
  #   a user.  A user may stash their credits and attach them to
  #   an identifier by texting a dollar amount to the number.
  #   The returned id number may be redeemed by texting the id number
  #   to the number.  building credit allows you to qualify for brand
  #   sponsorship.
  #
  def self.mint *c
    if c[0]
      cc = c[0]
    else
      cc = 1
    end
    U.new('BANK').coins.increment cc
  end
  def self.burn *c
    if c[0]
      cc = c[0]
    else
      cc = 1
    end
    U.new('BANK').coins.decrement cc
  end
  def self.supply
    U.new('BANK').coins.value
  end
  def self.wallet
    Redis::SortedSet.new("wallet")
  end
  def self.vault a
    i = []; VAULT_SIZE.times { i << rand(16).to_s(16) }
    Bank.vaults[i.join('')] = a
    return i.join('')
  end
  def self.vaults
    Redis::SortedSet.new('VAULT')
  end
  ##
  # save coins for later
  def self.stash h={}
    cns = (EXCHANGE[h[:host]].to_i || 1 * h[:amt]).to_i
    U.new(h[:from]).coins.decr(cns)
    U.new('BANK').wallet.incr('VAULT', cns)
    Bank.wallet.incr(h[:from], cns)
    U.new(h[:from]).log << %[STASH #{Time.now.utc} #{JSON.generate(h)}]
    return {
      id: Bank.vault(cns), 
      amt: cns,
      balance: U.new(h[:from]).coins.value,
      credit: Bank.wallet[h[:from]]
    }
  end
  
  ##
  # recover stashed coins 
  def self.recover h={}
    a = Bank.vaults[h[:id]].to_i
    Bank.vaults.delete(h[:id])
    U.new('BANK').wallet.decr('VAULT', a)
    U.new(h[:to]).coins.incr(a)
    Bank.wallet.decr(h[:to], a)
    U.new(h[:to]).log << %[RECOVER #{Time.now.utc} #{JSON.generate(h)}]
    return {
      id: h[:id],
      amt: a,
      balance: U.new(h[:to]).coins.value,
      credit: Bank.wallet[h[:to]]
    }
  end
  
  def self.xfer h={}
    b = U.new('BANK')
    f = U.new(h[:from] || 'BANK')
    f.wallet.decr(h[:type] || :gp, h[:amt].to_i)
    f.coins.decr(h[:amt].to_i)
    t = U.new(h[:to] || 'BANK')
    if h.has_key? :in
      d = h[:in]
    elsif h.has_key? :at
      d = timer(h[:at])
    else
      d = 0
    end
    if h[:fee]
      fee = ("#{d}".length * h[:fee].to_i).to_i
      f.coins.decr(fee)
      b.coins.incr(fee)
    end
    CRON.at(Time.now + d) do
      t.wallet.incr(h[:type] || :gp, h[:amt].to_i)
      t.coins.incr(h[:amt].to_i)
    end
  end
end

class CallCenter
  def initialize phone
    tree = {
      message: "OK",
      file: nil,
      mode: 'callcenter',
      boss: ENV['ADMIN'],
      dispatcher: ENV['ADMIN'],
      pool: [],
      pagers: { '0' => '' }
    }
    @phone = phone
    if !TREE.has_key? @phone
      TREE[@phone] = JSON.generate(tree)
    end
    @tree = JSON.parse(TREE[phone])
  end
  def [] k
    @tree[k.to_s]
  end
  def []= k,v
    @tree[k.to_s] = v
  end
  def << u
    @tree['pool'] << u
    @tree['pool'].uniq!
  end
  def save!
    TREE[@phone] = JSON.generate(@tree)
  end
end

class Sash
  def initialize u, *b
    @u = U.new(u)
  end
  def [] b
    {
      name: b,
      dependancies: DEPS[b],
      for: DESCRIPTIONS[b],
      badges: @u.badges[b],
      awards: @u.awards[b],
      stripes: @u.stripes[b],
      boss: @u.boss[b]
    }
  end
  def << b
    if [DEPS[b.to_sym]].flatten.length > 0
      d = false
      DEPS[b.to_sym].each { |e| if @u.boss[e].to_i > 1 || @u.attr[:boss].to_i > 0; d = true; end  }
    else
      d = true
    end
    if d == true;
      @u.badges.incr(b);
      @u.boss[b] = "#{@u.badges[b].to_i}".length
      @u.stripes[b] = "#{@u.boss[b].to_i}".length
      @u.log << %[<span class='material-icons'>military_awards</span> you earned a #{b} badge.]
    end
  end

  def colors b,f,d
    bg = { 0 => 'darkgrey', 1 => 'white', 2 => 'lightblue', 3 => 'lightgreen', 4 => 'red' }
    fg = { 0 => 'lightgrey', 1 => 'purple', 2 => 'orange', 3 => 'green', 4 => 'blue', 5 => 'red', 6 => 'brown', 7 => 'yellow', 8 => 'magenta' }
    bd = { 0 => 'darkgrey', 1 => 'purple', 2 => 'orange', 3 => 'green', 4 => 'blue', 5=> 'red', 6 => 'brown', 7 => 'yellow', 8 => 'magenta' }
    h =  { fg: fg[f.to_i] || 'gold', bg: bg[b.to_i] || 'black', bd: bd[d.to_i] || 'gold' }
  end
  
  def style b,f,d,p,r
    cl = colors(b,f,d)
    bd = ['none', 'solid', 'dotted']
    s = [%[background-color: #{cl[:bg]};]];
    s << %[color: #{cl[:fg]};]
    s << %[border: thick #{bd[p.to_i] || 'dashed'} #{cl[:bd]};]
    s << %[border-radius: #{r}px;]
    return { style: s.join(' '), colors: cl, }
  end

  def lvl
    r, ps = [], []
    if @u.attr[:boss].to_i > 0
      "#{@u.attr[:boss]}".length.times {
        ps << %[<span class='material-icons pin'>#{PINS[@u.attr[:class].to_i + 1]}</span>]
      }
    end
    @u.attr[:rank].to_i.times { r << %[<span class='material-icons pin'>#{PINS[0]}</span>] }    
    p = style("#{@u.attr[:boss].to_i}".length - 1, "#{@u.attr[:xp].to_i}".length - 1, @u.attr[:class], @u.attr[:class], 0)
    return %[<div id='lvl' style='#{p[:style]};'><div>#{ps.join('')}</div><div>#{r.join('')}</div></div>]
  end
  
  def badges
    r, t = [], Hash.new { |h,k| h[k] = 0 }
    @bgs = @u.badges.members(with_scores: true).to_h
    @bss = @u.boss.members(with_scores: true).to_h
    @awd = @u.awards.members(with_scores: true).to_h
    @stp = @u.stripes.members(with_scores: true).to_h
    BADGES.each_pair do |k,v|
      @u.boss[k.to_s] = "#{@bgs[k.to_s].to_i}".length - 1
      @u.stripes[k.to_s] = "#{@awd[k.to_s].to_i}".length
      t[:badges] += @bgs[k.to_s] || 0
      t[:boss] += @bss[k.to_s] || 0
      t[:awards] += @awd[k.to_s] || 0
      t[:stripes] += @stp[k.to_s] || 0
      if @bgs[k.to_s].to_i > 9
        g = "#{@bgs[k.to_s].to_i}"[-1]
      else
        g = @bgs[k.to_s]
      end
      if @awd[k.to_s].to_i > 9
        w = "#{@awd[k.to_s].to_i}"[0]
      else
        w = @awd[k.to_s]
      end
      p = style(@bss[k.to_s], g, w, @stp[k.to_s], 1000);
      r << %[<button class='material-icons badge' name='give[type]' value='#{k}' style='#{p[:style]}'>#{v}</button>]
    end
    @u.stat[:badges] = t[:badges]
    @u.stat[:boss] = t[:boss]
    @u.stat[:awards] = t[:awards]
    @u.stat[:stripes] = t[:stripes]
    return %[<div id='badges'>#{r.join('')}</div>]
  end
end

class JOB
  include Redis::Objects
  set :pool
  def initialize i
    @id = i
  end
  def id; @id; end
end
class Job
  include Redis::Objects
  hash_key :attr
  hash_key :item, marshal: true
  set :items
  def initialize u, j
    @user = U.new(u)
    @zone = Zone.new(@user.attr[:sponsor])
    JOB.new(j).pool << @user.id
    JOBS[j] = @user.id
    @id = "#{@user.id}:#{@user.attr[:sponsor]}:#{j}"
    @zone.jobs[@id] = @user.id
    @user.jobs << j
  end
  def id; @id; end
  def << h={}
    self.items << h[:body]
    @user.items << h[:body]
    @zone.items["#{@id}:#{h[:body]}"] = @user.id
    self.item["#{@id}:#{h[:body]}"] = h
  end
end

class U
  include Redis::Objects
  set :waypoints
  set :visited
  set :jobs
  set :items
  set :reps
  sorted_set :wallet
  sorted_set :awards
  sorted_set :stripes
  sorted_set :badges
  sorted_set :stat
  sorted_set :boss
  sorted_set :zap
  sorted_set :zapper
  sorted_set :zapped
  set :votes
  set :zones
  set :jobs
  set :titles
  hash_key :attr
  counter :coins
  counter :zaps
  counter :spaz
  list :log
  value :pin, expireat: 180
  value :password
  def initialize i
    @id = i
  end
  def id
    @id
  end
  def sash
    Sash.new(@id)
  end
end



class Tree
  include Redis::Objects
  hash_key :attr
  hash_key :chan
  hash_key :link
  def initialize i
    @id = i
  end
  def id; @id; end
end

class Domain
  include Redis::Objects
  hash_key :attr
  hash_key :stat
  set :zones
  sorted_set :users
  
  def initialize i
    @id = i
  end
  def id; @id; end
  def tree
    Tree.new(@id)
  end
end

class Badge
  def initialize u
    @id = u
    @user = U.new(u)
    if QRO.has_key? u
      @uid = QRO[u]
    else
      @uid = u
    end
  end
  def z
    zz = []; 12.times { zz << rand(16).to_s(16) };
    zzz = zz.join('')
    # do something on z create
    return zzz
  end
  def ts
    t = Time.now.utc.to_i
    # do something on ts create
    return t
  end
  def id; @id; end
  def member
    ##
    # key:
    # u: ORO[@id]
    # x: sponsor zone
    # b: boss level (brand privledge)
    # c: class level (network privledge)
    # r: adventure level ("completed adventures".length)
    # z: adventure neuton
    zo = CGI.escape("#{@user.attr[:zone] || 'solo' }")
    if QRO.has_key? @id
      return %[?b=#{@user.attr[:boss].to_i}&p=#{@user.attr[:xp].to_i}&r=#{@user.attr[:rank].to_i}&c=#{@user.attr[:class].to_i}&x=#{zo}&u=#{QRO[@id]}&z=#{z}]
    else
      return %[?b=#{@user.attr[:boss].to_i}&p=#{@user.attr[:xp].to_i}&r=#{@user.attr[:rank].to_i}&c=#{@user.attr[:class].to_i}&x=#{zo}&u=#{@id}&z=#{z}]
    end
  end
  def user
    ##
    # ts: last reload time index
    return %[#{member}&ts=#{ts}]
  end
  def zap
    return %[NOMAD@id]
  end
end

class Ui
  def initialize t
    @title = t
    @html = []
  end
  def html
    return %[<fieldset><legend>#{@title}</legend>#{@html.join('')}</fieldset>]
  end
  def button(t, h={});
    a = [];
    h.each_pair { |k,v|
      a << %[#{k}='#{v}']
    };
    @html << %[<button #{a.join(' ')}>#{t}</button>]
  end
  def input(h={});
    a = [];
    h.each_pair { |k,v|
      a << %[#{k}='#{v}']
    };
    @html << %[<input #{a.join(' ')}>];
  end
end
class UI
  def initialize
    @ui = Hash.new {|h,k| h[k] = Ui.new(k) }
  end
  def [] k
    @ui[k]
  end
  def html
    a = []
    @ui.each_pair {|k,v| a << v.html }
    return a.join('') 
  end
end

class K
  HELP = [
    %[<style>#help li code { border: thin solid black; padding: 1%; }</style>],
    %[<ul id='help'>],
    %[<li><code>cd :name</code><span>focus on a campaign.</span></li>],
    %[</ul>],
    %[<ul>],
    %[<li><button disabled>FS</button> edit the campaign files.</li>],
    %[<li>the campaign index files are the main focus of the campaign.</li>],
    %[<li>adding other files adds pins, app elements, and sub-campaign configuratons.</li>],
    %[</ul>]
  ].join('')
  TERM = [%[<style>#ui { width: 100%; text-align: center; } #ui > input { width: 65%; }],
          %[ #ls { height: 80%; overflow-y: scroll; font-size: small; }],
          %[ #ui > * { vertical-align: middle; }],
          %[ #ui > textarea { height: 80%; width: 100%; }<%= css %></style>],
          %[<h1 id='ui'>],
          %[<a href='/<%= @id %>' class='material-icons' style='border: thin solid black;'>home</a>],
          %[<button type='button' onclick='$("#ls").toggle();'>FS</button>],
          %[<input name='cmd' placeholder='<%= `hostname` %>'>],
          %[<button type='submit' class='material-icons'>send</button></h1>],
          %[<fieldset id='ls' style='display: none;'><legend><a href='/<%= QRO[id] %><%= pwd %>'><%= pwd %></legend></a><%= ls  %></fieldset>],
          %[<div id='output'><%= html %></div>],
          %[#{HELP}],
          %[<script>$(function() { <%= self.scripts.values.join('; ') %>; });</script>]].join('')
  include Redis::Objects
  list :content
  list :scripts
  list :styles
  value :dir
  hash_key :attr
  def initialize(i);
    @id = i;
  end
  def ls
    o = []
    "#{`ls -lha #{self.dir.value}`}".split("\n").each {|e|
      skip = false
      f = e.split(' ')[-1]
      if /^d/.match(e)
        if /\.$/.match(e) || /\.\.$/.match(e)
          b = %[]
          skip = true
        else
          b = %[<button class='material-icons' name='cmd' value='cd("#{f}")'>folder</button>]
        end
      elsif /^total/.match(e)
        b = %[]
        skip = true
      else
        if /.markdown/.match(e)
          b = %[<button class='material-icons' name='cmd' value='edit("#{f}")'>post_add</button>]
        elsif /.erb/.match(e)
          b = %[<button class='material-icons' name='cmd' value='edit("#{f}")'>article</button>]
        elsif /.json/.match(e)
          b = %[<button class='material-icons' name='cmd' value='edit("#{f}")'>list</button>]
        end
      end
      if skip == false
        o << %[<p>#{b} #{e}</p>]
      end
    }
    return "<div>" + o.join('') + "</div>"
  end
  def cd *d
    self.dir.value = %[#{home}/#{d[0]}]
    if !Dir.exist? self.dir.value
      Dir.mkdir(self.dir.value)
    end
    if !File.exist?("#{self.dir.value}/index.json") && d.length > 0
      h = { goal: '', ga: '', fb: '', zone: U.new(@id).attr[:zone] }
      File.open("#{self.dir.value}/index.json", "w") { |f| f.write("#{JSON.generate(h)}"); }
      File.open("#{self.dir.value}/index.erb", "w") { |f| f.write("<h1>Hello, World!</h1>created: </h3><p><% Time.now.utc %></p>"); }
      File.open("#{self.dir.value}/index.markdown", "w") { |f| f.write("# Hello, World!\n\n## markdown is a simple way to organize text to be rendered as html.\n- it supports lists.\n- and tables,\n- etc.\n- google it."); }
    end
    return "#{self.dir.value.gsub(home, '')}"
  end
  def pwd
    if self.dir.value == nil
      self.dir.value = home
    end
    "#{self.dir.value}".gsub(home, '')
  end
  def home
    %[home/#{@id}]
  end
  def term
    ERB.new(TERM).result(binding)
  end
  def clear
    self.content.clear
    return nil
  end
  def peek
    markdown = Redcarpet::Markdown.new(Redcarpet::Render::HTML, filter_html: true)
    o = []
    Dir["#{home}/*"].each {|f|
      if /.json/.match(f)
        o << "<fieldset><legend>#{f.gsub(home, '')}</legend>" + File.read(f) + "</fieldset>"
      elsif /.erb/.match(f)
        o << "<fieldset><legend>#{f.gsub(home, '')}</legend>" + ERB.new(File.read(f)).result(binding) + "</fieldset>"
      elsif /.markdown/.match(f)
        o << "<fieldset><legend>#{f.gsub(home, '')}</legend>" + markdown.render(File.read(f)) + "</fieldset>"
      end
    }
    return o.join('')
  end
  def id; @id; end
  
  def html
    o = []
    if self.attr[:file] == nil
      self.content.values.each {|e| o << e }
    else
      f = "#{self.dir.value}/#{self.attr[:file]}"
      if File.exist? f
        ff = File.read(f)
      else
        ff = ''
      end
      o << [%[<input type='hidden' name='editor[file]' value='#{f}'>],
            %[<textarea name='editor[content]' style='width: 100%; height: 80%;'>#{ff}</textarea>]].join('')
      
    end
    return o.join('')
  end
  def js
    self.scripts.values.join('; ')
  end
  def style a, h={}
    o = []; h.each_pair {|k,v| o << %[#{k}: #{v}] }
    self.styles << %[#{a} { #{o.join('; ')} }]
  end
  def css
    self.styles.values.join('')
  end
  def puts(e); return "#{e}"; end;
  def help; ERB.new(HELP).result(binding); end
  def edit(f);
    self.attr[:file] = f
  end
  def conf(*f)
    edit "#{f[0] || 'index'}.json"
  end
  def app(*f)
    edit "#{f[0] || 'index'}.erb"
  end
  def pin(*f)
    edit "#{f[0] || 'index'}.markdown"
  end
  
  
  def button(t, h={}); a = []; h.each_pair { |k,v| a << %[#{k}='#{v}'] };
    return %[<button #{a.join(' ')}>#{t}</button>]
  end
  def input(h={}); a = []; h.each_pair { |k,v| a << %[#{k}='#{v}'] }; return %[<input #{a.join(' ')}>]; end
  def sh c
    return `#{c}`.chomp!
  end
  def eval(e);
    begin;
      if e == ''; e = 'help'; end
      e.split(';').each { |ea| self.content << "#{self.instance_eval(ea)}".gsub("\n", '<br>') }
    rescue => e
      self.content << "<p>#{e.class} #{e.message}</p>"
    end
  end
end

class Chance
  include Redis::Objects
  list :cards, marshal: true
  value :res, marshal: true
  value :try
  def initialize i
    @id = i
    @u = U.new(@id)
  end
  def id; @id; end
  def deal *n
    a, aa, t = [], [], 0
    [self.cards.shift(n[0].to_i || 1)].flatten.each {|e| t += e[:value]; a << e }
    a.each {|e| aa << %[#{e[:card]}#{e[:suit]}] }
    return { total: t, result: aa }                            
  end
  def try?
    if @u.attr.has_key?(:chance) && @u.attr[:chance] != 'none'
      return true
    else
      return false
    end
  end
  def try!
    @n = @u.attr[:rank].to_i + 1
    case @u.attr[:chance]
    when 'coin'
      t, a = 0, []; @n.times { c = coin; t += c[:total]; a << c[:result] }
      self.res.value = { total: t, result: a }
    when 'card'
      if self.cards.values.length - @n  >= 0
        deck
      end
      self.res.value = deal(@n)
    when 'dice'
      self.res.value = roll("#{@n}d#{@u.attr[:class].to_i + 1}") {|r| r }
    end
    self.try.value = success(result)
    return success?
  end
  def success i
    Redis.new.publish("CHANCE.success", "#{i} #{@u.attr.all}")
    if i[:total].to_i >= @u.attr[:rank].to_i
      return true
    else
      return false
    end
  end
  def success?
    self.try.value
  end
  def result
    self.res.value
  end
  def deck h={}
    de = []
    hh = {
      suits: ["&#9829;", "&#9830;", "&#9824;", "&#9827;"],
      numbers: (2..10).to_a,
      faces: [ :A, :K, :Q, :J ],
      special: [ :"&#x1F0CF;", :"&#x1F004;" ],
    }.merge(h)
    Redis.new.publish("CHANCE.deck", "#{hh}")
    self.cards.clear
      [hh[:suits]].flatten.each { |s|
        Redis.new.publish("CHANCE.deck.s", "#{s}")
        [:faces, :numbers].each { |k|
          Redis.new.publish("CHANCE.deck.k", "#{k}")
          if hh.has_key? k.to_sym
            [hh[k]].flatten.each {|e|
              if /\d+/.match("#{e}")
                v = e.to_i
              else
                v = 10
              end
              de << { suit: s, card: e, value: v }
              Redis.new.publish("CHANCE.deck.card", "s#{s} c#{e} v#{v}")
            }
          end
        }
      }
      [hh[:special]].flatten.each {|e| de << { suit: "#", card: e, value: 0 };
        Redis.new.publish("CHANCE.deck.special", "#{e}")
      }
    Redis.new.publish("CHANCE.deck.de", "#{de}")
    de.shuffle!
    de.each {|e| self.cards << e }
  end
  def coin
    c = rand(2)
    if c == 0
      t = "arrow_circle_up"
    else
      t = "arrow_circle_down"
    end
    Redis.new.publish("CHANCE.coin", "#{c} #{t}")
    { total: c, result: %[<span class='material-icons' style='vertical-align: middle;'>#{t}</span>] }
  end
  def roll i, &b
    b.call(die(i))
  end
  def die i
    r, tot = [], 0
    ii = i.split('d')
    ii[0].to_i.times { x = rand(ii[1].to_i) + 1; tot += x; r << x }
    Redis.new.publish("CHANCE.dice", "#{tot} #{r}")
    return { total: tot, result: r }
  end
  def zap u
    me = U.new(@id)
    a = "#{me.attr[:xp]}".length + 1
    you = U.new(u)
    me.zaps.increment
    you.spaz.increment
    d = "#{you.attr[:xp]}".length + 1
    z = die("#{d}d#{you.attr[:rank].to_i + you.attr[:class].to_i}")
    roll("#{a}d#{me.attr[:rank].to_i + me.attr[:class].to_i}") {|h|
      ic = %[<span class='material-icons'>crisis_alert</span>]
      icn_hit = %[<span class='material-icons' style='color: red;'>ads_click</span>]
      icn_miss = %[<span class='material-icons' style='color: green;'>adjust</span>]
      if h[:total] > z[:total]
        r = 1
        me.zapper.incr(you.id)
        me.zap.incr(you.id)
        you.zap.incr(me.id)
        you.zapped.incr(me.id)
        me.attr.incr(:xp)
        icn = %[<span class='material-icons'>crisis_alert</span>]
        me.log << %[#{icn_hit} you zapped #{you.attr[:name] || 'another player'}.]
        you.log << %[#{icn_hit} you got zapped by #{me.attr[:name] || 'another player'}.]
      else
        r = 0
        me.zap.incr(you.id)
        you.zap.incr(me.id)
        icn = %[<span class='material-icons'>crisis_alert</span>]
        me.log << %[#{icn_miss} you missed #{you.attr[:name] || 'another player'}.]
        you.log << %[#{icn_miss} #{me.attr[:name] || 'another player'} missed you.]
      end
      me.attr.incr(:xp)
      you.attr.incr(:xp)
      u, t = 0, 0
      me.zapper.members(with_scores: true).to_h.each_pair {|k,v| u += 1; t += v }
      me.attr[:rank] = ( "#{me.zaps.value}".length + "#{me.spaz.value}".length ) - 1
      you.attr[:rank] = ( "#{you.zaps.value}".length + "#{you.spaz.value}".length ) - 1
      me.log << %[<span class='material-icons'>emoji_events</span>rank: #{me.attr[:rank]}]
      you.log << %[<span class='material-icons'>emoji_events</span>rank: #{you.attr[:rank]}]
      { me: h, you: z, total: r }
    }
  end
end
